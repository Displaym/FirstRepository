#include <iostream>

using namespace std;

int main() {
  enum paytype { CARD, CHECK
  };
  paytype ptype;
  union payment {
    char card[25];
    long check;
  }
  info;
  // присваивание значений info и ptype
  switch(ptype) {
    case CARD: cout << "Оплата по карте: " << info.card;
    break;
    case CHECK: cout << "Оплата чеком " << info.check;
    break;
  }
return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>

using namespace std;

int main() {
  enum paytype {CARD, CHECK}ptype;
  struct {
    //paytype ptype;
    union payment {
      char card[25];
      long check;
    };
  }
  info;
  switch(ptype) {
    case CARD: cout << "Оплата по карте: " << info.card;
    break;
    case CHECK: cout << "Оплата чеком: " << info.check;
    break;
  }
return 0;
}
/////////////////////////////////////////////////////////////////////////////
#include <iostream>

using namespace std;

int main() {
  //анонимное объединение
  union {
    short int count;
    char ch[2];
  }
  //как происходит непосредственные обращения к членам анонимного объединения//
  ch[0] = 'X';
  ch[1] = 'Y';
  cout << "Объединение в виде символов: " << ch[0] << ch[1] << endl;
  cout << "Объединение в виде целого значения: " << count << endl;
return 0;
}
//////////////////////////////////////////////////////////////////////////////////
#include <iostream>

int main() {
  class queue {
    int q[100];
    int sloc, vloc;
    public:
    queue(); //конструктор
    ~queue(); // деструктор
    void qput(int i);
    int qyet();
  };
  //определение
  queue::queue() {
    sloc = vloc = 0;
    cout << "Очередь инициализирована." << endl;
  }
  //определение деструктора
  queue::~queue() {
    cout << "Очередь разрешена" << endl;
  }
  //Значение в очередь целочисленного значения 
  void queue:: qput(int i) {
    if (sloc == 100) {
      cout << "Очередь заполна" << endl;
      return;
    }
    sloc++;
    q[sloc] = i;
  }
  //Извищение из очереди целочисленного значения
  int queue:: qyet() {
    if (vloc == sloc) {
      cout << "Очередь пуста" << endl;
      return 0;
    }
    vloc++;
    return q[vloc];
  }
  int main() {
    queue a,b; //создание двух объектов класса queue
    a.qput(10);
    b.qput(19);
    a.qput(20);
    b.qput(1);
    cout << a.qyet() << " ";
    cout << a.qyet() << " ";
    cout << b.qyet() << " ";  
    cout << b.qyet() << endl;
return 0;
  }
}
///////////////////////////////////////////////////////////////////////////////////////
#include <iostream>

using namespace std;

int main() {
  struct cl {
    int get_i(); // public
    void put_i(int j); // по умножению
    private:
    int i;
  };
  int cl:: get_i() {
    return i;
  }
  void cl::put_i(int j) {
    i = j;
  }
  int main() {
    cl s;
    s.put_i(10);
    cout << s.get_i();
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////
#include <iostream>

using namespace std;

class cl {
  int i; //закрытый член по умолчанию
  public:
  int get_i():
  void put_i(int j):
};
int cl:: get_i() {
  return i;
}
void cl:: put_i(int j) {
  i = j;
}

int main() {
  cl s;
  s.put_i(10);
  cout << s.get_i();
  return 0;
}
///////////////////////////////////////////////////////////////////////////////////////
#include <iostream>

using namespace std;

union u_type {
  u_type(short int a); //открытые по умолчанию
  void showchar();
  short int i;
  char ch[2];
};
//конструктор
u_type:: u_type(short int a) {
  i = a;
}
// отображение символов составляющих значение типа short int
void u_type :: showchar() {
  cout << ch[0] << " ";
  cout << ch[1] << endl;
}
int main() {
  u_type u(1000);
  u.showchar();
return 0;
}
